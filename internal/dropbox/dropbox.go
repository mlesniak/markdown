package dropbox

import (
	"bytes"
	"github.com/labstack/echo/v4"
	"github.com/labstack/gommon/log"
	"github.com/mlesniak/markdown/internal/cache"
	"github.com/mlesniak/markdown/internal/markdown"
	"strings"
)

// Service contains the necessary data to access a dropbox.
type Service struct {
	// The token is either generated by the normal OAuth2 workflow from
	// dropbox or a token manually generated using the app console for your
	// specific application.
	Token         string
	AppSecret     string
	RootDirectory string
	Log           echo.Logger

	// Since we have only one account, the cursor is part of the service.
	cursor string
	queue  chan string
}

type entry struct {
	Tag  string `json:".tag"`
	Name string `json:"name"`
}

// Get returns a new dropbox service.
func New(s Service) *Service {
	if !strings.HasSuffix(s.RootDirectory, "/") {
		panic("rootDirectory without / suffix:" + s.RootDirectory)
	}

	s.queue = make(chan string)
	return &s
}

func (s *Service) UpdateFiles(filenames ...string) {
	for _, filename := range filenames {
		go func(filename string) {
			s.Log.Infof("Adding to queue filename=%s", filename)
			s.queue <- filename
		}(filename)
	}
}

func (s *Service) Start() {
	go func() {
		s.Log.Info("Starting update queue watching...")
		for {
			filename := <-s.queue
			s.Log.Infof("Updating file %s", filename)
			bs, err := s.Read(s.Log, filename)
			if err != nil {
				panic(err)
			}
			s.updateFile(filename, bs)
		}
	}()
}

// updateFile receives a markdown file, renders its HTML, updates the tag list
// and updates the corresponding cache entry.
func (s *Service) updateFile(filename string, data []byte) {
	// Just to be sure we do not accidentally serve a non-public, but linked file.
	if !isPublic(data) {
		s.Log.Warnf("Preventing caching of non-public filename=%s", filename)
		return
	}

	// Update tag list.
	// tagList := utils.GetTags(data)
	// tagsService.Update(filename, tagList)

	// Render file.
	html, _ := markdown.ToHTML(s.Log, data)

	// Populate cache
	log.Infof("Update cache for filename=%s", filename)
	cache.Get().AddEntry(cache.Entry{
		Name: filename,
		Data: []byte(html),
	})
}

// Tag name to define markdown files which are allowed to be published.
const publishTag = "#public"

// isPublic checks if a file is allowed to be displayed: Since we are only
// downloading markdown files, we enforce that all files must contain the tag
// `publishTag` to be able to download it.
func isPublic(bs []byte) bool {
	return bytes.Contains(bs, []byte(publishTag))
}
