package dropbox

import (
	"bytes"
	"github.com/labstack/echo/v4"
	"github.com/mlesniak/markdown/internal/cache"
	"github.com/mlesniak/markdown/internal/markdown"
	"github.com/mlesniak/markdown/internal/tags"
	"github.com/mlesniak/markdown/internal/utils"
	"strings"
)

type queueEntry struct {
	filename  string
	finalizer func([]byte)
}

// Service contains the necessary data to access a dropbox.
type Service struct {
	// The token is either generated by the normal OAuth2 workflow from
	// dropbox or a token manually generated using the app console for your
	// specific application.
	Token         string
	AppSecret     string
	RootDirectory string
	Log           echo.Logger

	// Since we have only one account, the cursor is part of the service.
	cursor string
	queue  chan queueEntry
}

type entry struct {
	Tag  string `json:".tag"`
	Name string `json:"name"`
}

// Get returns a new dropbox service.
func New(s Service) *Service {
	if !strings.HasSuffix(s.RootDirectory, "/") {
		panic("rootDirectory without / suffix:" + s.RootDirectory)
	}

	s.queue = make(chan queueEntry)
	return &s
}

func (s *Service) Start() {
	s.Log.Info("Starting update queue watching...")
	go func() {
		for {
			entry := <-s.queue
			go s.processQueueEntry(entry)
		}
	}()
}

func (s *Service) processQueueEntry(entry queueEntry) {
	filename := entry.filename
	s.Log.Infof("Updating file %s", filename)
	bs, err := s.Read(s.Log, filename)
	if err != nil {
		panic(err)
	}
	bsHTML := s.convert(filename, bs)
	entry.finalizer(bsHTML)
}

// convert receives a markdown file, renders its HTML, updates the tag list
// and updates the corresponding cache entry.
// TODO Is this the right position?
func (s *Service) convert(filename string, data []byte) []byte {
	if !isPublic(data) {
		s.Log.Warnf("Preventing caching of non-public filename=%s", filename)
		return nil
	}

	tagList := utils.GetTags(data)
	tags.Get().Update(filename, tagList)

	s.Log.Infof("Converting markdown to HTML for filename=%s", filename)
	html, _ := markdown.ToHTML(s.Log, data)

	s.Log.Infof("Update cache for filename=%s", filename)
	cache.Get().AddEntry(cache.Entry{
		Name: filename,
		Data: []byte(html),
	})

	return []byte(html)
}

// isPublic checks if a file is allowed to be displayed by enforcing
// the existence of a text string in each file.
func isPublic(bs []byte) bool {
	publicTag := "#public"
	return bytes.Contains(bs, []byte(publicTag))
}
