package dropbox

import (
	"bytes"
	"github.com/labstack/echo/v4"
	"github.com/mlesniak/markdown/internal/backlinks"
	"github.com/mlesniak/markdown/internal/cache"
	"github.com/mlesniak/markdown/internal/markdown"
	"github.com/mlesniak/markdown/internal/tags"
	"github.com/mlesniak/markdown/internal/utils"
	"regexp"
	"strings"
)

type queueEntry struct {
	filename  string
	finalizer func([]byte)
}

// Service contains the necessary data to access a dropbox.
type Service struct {
	// The token is either generated by the normal OAuth2 workflow from
	// dropbox or a token manually generated using the app console for your
	// specific application.
	Token         string
	AppSecret     string
	RootDirectory string
	Log           echo.Logger

	// Since we have only one account, the cursor is part of the service.
	cursor string
	queue  chan queueEntry
}

type entry struct {
	Tag  string `json:".tag"`
	Name string `json:"name"`
}

// Get returns a new dropbox service.
func New(s Service) *Service {
	if !strings.HasSuffix(s.RootDirectory, "/") {
		panic("rootDirectory without / suffix:" + s.RootDirectory)
	}

	s.queue = make(chan queueEntry)
	return &s
}

func (s *Service) StartCacheQueue() {
	s.Log.Info("Starting update queue watching...")
	go func() {
		for {
			entry := <-s.queue
			go s.processQueueEntry(entry)
		}
	}()
}

func (s *Service) processQueueEntry(entry queueEntry) {
	filename := entry.filename
	s.Log.Infof("Updating file %s", filename)
	// bs, err := s.Read(s.Log, filename)
	// if err != nil {
	// 	panic(err)
	// }
	// bsHTML := s.convert(filename, bs)
	// entry.finalizer(bsHTML)
}

// convert receives a markdown file, renders its HTML, updates the tag list
// and updates the corresponding cache entry.
// TODO Is this the right position?
func (s *Service) convert(filename string, data []byte) []byte {
	if !isPublic(data) {
		s.Log.Warnf("Preventing caching of non-public filename=%s", filename)
		return nil
	}

	tagList := utils.GetTags(data)
	tags.Get().Update(filename, tagList)

	s.Log.Infof("Converting markdown to HTML for filename=%s", filename)
	html, _ := markdown.ToHTML(s.Log, filename, data)

	s.Log.Infof("Update cache for filename=%s", filename)
	cache.Get().AddEntry(cache.Entry{
		Name: filename,
		Data: []byte(html),
	})

	return []byte(html)
}

func (s *Service) PreloadCache(filenames ...string) {
	visitedFiles := make(map[string]struct{})
	queue := filenames

	// TODO Parallelize
	fileBuffers := make(map[string][]byte)
	for len(queue) > 0 {
		filename := queue[0]
		queue = queue[1:]

		if _, visited := visitedFiles[filename]; visited {
			continue
		}
		visitedFiles[filename] = struct{}{}

		s.Log.Infof("Reading file. filename=%s", filename)
		bs, err := s.Read(filename)
		if err != nil {
			s.Log.Infof("File found found. filename=%s", filename)
			continue
		}

		if !isPublic(bs) {
			s.Log.Warnf("Preventing caching of non-public file. filename=%s", filename)
			continue
		}

		links := getLinks(bs)
		queue = append(queue, links...)

		fileBuffers[filename] = bs
	}

	s.Log.Infof("Queued: %d files", len(fileBuffers))

	for filename, bs := range fileBuffers {
		ts := getTags(bs)
		tags.Get().Update(filename, ts)

		bls := getLinks(bs)
		backlinks.Get().AddTargets(filename, bls)

		html, _ := markdown.ToHTML(s.Log, filename, bs)
		s.Log.Infof("Adding cache entry. filename=%s", filename)
		cache.Get().AddEntry(cache.Entry{
			Name: filename,
			Data: []byte(html),
		})
	}

	// TODO Add tag pages into cache
	// Link to tag-<tag>
	// Modify handler
}

func getLinks(data []byte) []string {
	markdown := string(data)
	regex := regexp.MustCompile(`\[\[(.*?)\]\]`)

	links := []string{}

	submatches := regex.FindAllStringSubmatch(markdown, -1)
	for _, matches := range submatches {
		link := matches[1]
		if !strings.HasSuffix(link, ".md") {
			link = link + ".md"
		}
		links = append(links, link)
	}

	return links
}

func getTags(data []byte) []string {
	markdown := string(data)
	regex := regexp.MustCompile(` *(#\w+)`)
	matches := regex.FindAllString(markdown, -1)

	tags := []string{}

	for _, tag := range matches {
		if tag != "" {
			// Triming is easier than using the matcher's group.
			tag = strings.Trim(tag, " \n\r\t")
			tags = append(tags, tag)
		}
	}

	return tags
}

// isPublic checks if a file is allowed to be displayed by enforcing
// the existence of a text string in each file.
func isPublic(bs []byte) bool {
	publicTag := "#public"
	return bytes.Contains(bs, []byte(publicTag))
}
