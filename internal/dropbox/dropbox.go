package dropbox

import (
	"bytes"
	"github.com/labstack/echo/v4"
	"github.com/mlesniak/markdown/internal/backlinks"
	"github.com/mlesniak/markdown/internal/cache"
	"github.com/mlesniak/markdown/internal/markdown"
	"github.com/mlesniak/markdown/internal/tags"
	"github.com/mlesniak/markdown/internal/utils"
	"strings"
)

// Service contains the necessary data to access a dropbox.
type Service struct {
	// The token is either generated by the normal OAuth2 workflow from
	// dropbox or a token manually generated using the app console for your
	// specific application.
	Token         string
	AppSecret     string
	RootDirectory string
	Log           echo.Logger

	// Since we have only one account, the cursor is part of the service.
	cursor string
}

// Get returns a new dropbox service.
func New(s Service) *Service {
	if !strings.HasSuffix(s.RootDirectory, "/") {
		panic("rootDirectory without / suffix:" + s.RootDirectory)
	}

	return &s
}

func (s *Service) UpdateCache(filenames ...string) {
	fileBuffers := s.loadFiles(filenames)
	tags := s.processFiles(fileBuffers)
	s.generateTagPages(tags)
}

func (s *Service) loadFiles(filenames []string) map[string][]byte {
	fileBuffers := make(map[string][]byte)
	visitedFiles := make(map[string]struct{})
	queue := filenames
	for len(queue) > 0 {
		filename := queue[0]
		queue = queue[1:]

		if _, visited := visitedFiles[filename]; visited {
			continue
		}
		visitedFiles[filename] = struct{}{}

		s.Log.Infof("Reading file. filename=%s", filename)
		bs, err := s.Read(filename)
		if err != nil {
			s.Log.Infof("File found found. filename=%s", filename)
			continue
		}

		if !isPublic(bs) {
			s.Log.Warnf("Preventing caching of non-public file. filename=%s", filename)
			continue
		}

		links := backlinks.GetLinks(bs)
		queue = append(queue, links...)

		fileBuffers[filename] = bs
	}
	s.Log.Infof("Queued: %d files", len(fileBuffers))
	return fileBuffers
}

func (s *Service) generateTagPages(tagMap map[string][]string) {
	for tag, filenames := range tagMap {
		tagName := "tag-" + tag[1:]
		s.Log.Infof("Adding tag to cache. filename=%s", tagName)
		bs := tags.GenerateTagPage(s.Log, tag, filenames)
		cache.Get().AddEntry(cache.Entry{
			Name: tagName,
			Data: bs,
		})
	}
}

func (s *Service) processFiles(fileBuffers map[string][]byte) map[string][]string {
	tagMap := make(map[string][]string)
	for filename, bs := range fileBuffers {
		ts := utils.GetTags(bs)
		for _, t := range ts {
			_, found := tagMap[t]
			if !found {
				tagMap[t] = []string{filename}
			} else {
				// Does this work on empty, too?
				tagMap[t] = append(tagMap[t], filename)
			}
		}

		bls := backlinks.GetLinks(bs)
		backlinks.Get().AddTargets(filename, bls)

		html, _ := markdown.ToHTML(s.Log, filename, bs)
		s.Log.Infof("Adding cache entry. filename=%s", filename)
		cache.Get().AddEntry(cache.Entry{
			Name: filename,
			Data: []byte(html),
		})
	}
	return tagMap
}

// isPublic checks if a file is allowed to be displayed by enforcing
// the existence of a text string in each file.
func isPublic(bs []byte) bool {
	publicTag := "#public"
	return bytes.Contains(bs, []byte(publicTag))
}
